// // SPDX-License-Identifier: MIT
// pragma solidity ^0.8.24;

// import "@openzeppelin/contracts/access/Ownable.sol";

// /**
//  * @title ReputationSystem
//  * @notice Simple, agent-driven reputation system
//  * @dev Agents monitor HCS and call functions to update reputation based on task outcomes
//  */
// contract ReputationSystem is Ownable {
    
//     // ═══════════════════════════════════════════════════════════
//     // STATE
//     // ═══════════════════════════════════════════════════════════
    
//     struct Profile {
//         uint256 reputationScore;      // 0-1000
//         uint256 tasksCompleted;
//         uint256 tasksRejected;
//         uint256 lastUpdate;
//     }
    
//     mapping(address => Profile) public profiles;
//     mapping(address => mapping(string => uint256)) public domainScores; // user → domain → score
    
//     address public marketplace;  // Only marketplace can call certain functions
//     address public agent;        // Trusted agent that monitors HCS and updates reputation
    
//     // ═══════════════════════════════════════════════════════════
//     // EVENTS
//     // ═══════════════════════════════════════════════════════════
    
//     event ReputationUpdated(address indexed user, uint256 newScore);
//     event TaskCompleted(address indexed user, string domain);
//     event TaskRejected(address indexed user);
    
//     // ═══════════════════════════════════════════════════════════
//     // MODIFIERS
//     // ═══════════════════════════════════════════════════════════
    
//     modifier onlyMarketplace() {
//         require(msg.sender == marketplace, "Only marketplace");
//         _;
//     }
    
//     modifier onlyAgent() {
//         require(msg.sender == agent, "Only agent");
//         _;
//     }
    
//     // ═══════════════════════════════════════════════════════════
//     // SETUP
//     // ═══════════════════════════════════════════════════════════
    
//     constructor() Ownable(msg.sender) {}
    
//     function setMarketplace(address _marketplace) external onlyOwner {
//         require(_marketplace != address(0), "Invalid address");
//         marketplace = _marketplace;
//     }
    
//     function setAgent(address _agent) external onlyOwner {
//         require(_agent != address(0), "Invalid address");
//         agent = _agent;
//     }
    
//     // ═══════════════════════════════════════════════════════════
//     // AGENT FUNCTIONS (Called after monitoring HCS events)
//     // ═══════════════════════════════════════════════════════════
    
//     /**
//      * @notice Record successful task completion
//      * @dev Called by agent after seeing "ANNOTATION_APPROVED" on HCS
//      */
//     function recordTaskApproved(address user, string calldata domain) external onlyAgent {
//         require(user != address(0), "Invalid user");
        
//         Profile storage profile = profiles[user];
//         profile.tasksCompleted++;
//         profile.lastUpdate = block.timestamp;
        
//         // Update domain expertise
//         domainScores[user][domain] += 10;
        
//         // Recalculate score
//         profile.reputationScore = _calculateScore(user);
        
//         emit TaskCompleted(user, domain);
//         emit ReputationUpdated(user, profile.reputationScore);
//     }
    
//     /**
//      * @notice Record task rejection
//      * @dev Called by agent after seeing "ANNOTATION_REJECTED" on HCS
//      */
//     function recordTaskRejected(address user) external onlyAgent {
//         require(user != address(0), "Invalid user");
        
//         Profile storage profile = profiles[user];
//         profile.tasksRejected++;
//         profile.lastUpdate = block.timestamp;
        
//         // Recalculate score (will be lower)
//         profile.reputationScore = _calculateScore(user);
        
//         emit TaskRejected(user);
//         emit ReputationUpdated(user, profile.reputationScore);
//     }
    
//     // ═══════════════════════════════════════════════════════════
//     // MARKETPLACE FUNCTIONS
//     // ═══════════════════════════════════════════════════════════
    
//     /**
//      * @notice Award reputation directly (for backward compatibility)
//      * @dev Called by marketplace when annotation is approved
//      */
//     function awardReputation(address user, uint256 amount) external onlyMarketplace {
//         require(user != address(0), "Invalid user");
//         require(amount > 0, "Amount must be positive");
        
//         profiles[user].reputationScore += amount;
//         if (profiles[user].reputationScore > 1000) {
//             profiles[user].reputationScore = 1000; // Cap at 1000
//         }
        
//         emit ReputationUpdated(user, profiles[user].reputationScore);
//     }
    
//     // ═══════════════════════════════════════════════════════════
//     // QUERY FUNCTIONS
//     // ═══════════════════════════════════════════════════════════
    
//     /**
//      * @notice Get user's reputation score
//      */
//     function getReputation(address user) external view returns (uint256) {
//         return profiles[user].reputationScore;
//     }
    
//     /**
//      * @notice Get user's domain expertise
//      */
//     function getDomainScore(address user, string calldata domain) external view returns (uint256) {
//         return domainScores[user][domain];
//     }
    
//     /**
//      * @notice Get user's success rate
//      */
//     function getSuccessRate(address user) external view returns (uint256) {
//         Profile storage profile = profiles[user];
//         uint256 total = profile.tasksCompleted + profile.tasksRejected;
        
//         if (total == 0) return 0;
//         return (profile.tasksCompleted * 100) / total;
//     }
    
//     /**
//      * @notice Check if user meets minimum reputation
//      */
//     function meetsMinimum(address user, uint256 minimum) external view returns (bool) {
//         return profiles[user].reputationScore >= minimum;
//     }
    
//     // ═══════════════════════════════════════════════════════════
//     // REPUTATION CALCULATION (Simple weighted formula)
//     // ═══════════════════════════════════════════════════════════
    
//     /**
//      * @notice Calculate reputation based on success rate and volume
//      * @dev Simple formula: (successRate * 8 + volumeScore * 2)
//      */
//     function _calculateScore(address user) internal view returns (uint256) {
//         Profile storage profile = profiles[user];
        
//         uint256 total = profile.tasksCompleted + profile.tasksRejected;
//         if (total == 0) return 0;
        
//         // Success rate (0-100)
//         uint256 successRate = (profile.tasksCompleted * 100) / total;
        
//         // Volume score (logarithmic)
//         uint256 volumeScore = _volumeScore(total);
        
//         // Weighted formula: 80% success rate, 20% volume
//         uint256 score = (successRate * 8) + (volumeScore * 2);
        
//         return score > 1000 ? 1000 : score;
//     }
    
//     /**
//      * @notice Volume score with diminishing returns
//      */
//     function _volumeScore(uint256 taskCount) internal pure returns (uint256) {
//         if (taskCount == 0) return 0;
//         if (taskCount >= 100) return 100;
//         if (taskCount >= 50) return 80 + (taskCount - 50) / 2;
//         if (taskCount >= 10) return 50 + (taskCount - 10);
//         return taskCount * 5;
//     }
// }